<title>Christoph Schwarzweller: Haskell</title>
<link rel="stylesheet" type="text/css" href="../cs.css"/>
</head>

<body class="main">

	<br>
	<H2> Zadania (Haskell) </H2>
	<br>
	<ol>
		<li>  Jakie s&#x0105; warto&#x015B;ci nast&#x0119;puj&#x0105;cych wyra&#x017C;e&#x0144;?
		<br><br>
		<pre>
> 10 <br><br>
> 5 + 3 + 4 <br><br>
> 9 - 1  <br><br>
> 6 / 2 <br><br>
> 2 * 3 + 4 * 6 <br><br>
> let a = 3 in a + 1 <br><br>
> let a = 1 in let b = a + 1 in a + b + a * b <br><br>
> let square n = n * n in square 4 <br><br>
> let fac n = if n == 0 then 1 else n * fac (n-1) in fac 5 <br><br>

</pre>

		<li> Prosz&#x0119; napisa&#x0107; funkcje
		<tt>smaller x y</tt>, <tt>greater x y</tt>, <tt>equal x y</tt>, <tt>smaller_equal x y</tt>, <tt>greater_equal x y</tt> oraz <tt>not_equal x y</tt>.
		Nale&#x017C;y z wbudowanych funkcji u&#x017C;ywa&#x0107; wy&#x0142;&#x0105;cznie funckcj&#x0119; <tt><</tt> (oraz predykaty oczywi&#x015B;cie). <br><br>

		<li> Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt>call_with_5 f</tt>, kt&#x00F3;rej warto&#x015B;&#x0107; jest warto&#x015B;ci&#x0105; funkcji f dla argumentu <tt>5</tt>.
		<pre>Przyk&#x0142;ad: > call_with_5 square
          25
</pre>
		Jaka jest warto&#x015B;&#x0107; wyra&#x017C;enia <tt>call_with_5 call_with_5</tt>? <br><br>

		<li> Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt>same_values p1 p2 x y</tt>, kt&#x00F3;rej warto&#x015B;&#x0107; jest <tt>True</tt>, je&#x017C;eli <tt>p1(x,y)</tt> i <tt>p2(x,y)</tt> maj&#x0105; t&#x0105; sam&#x0105; warto&#x015B;&#x0107; i <tt>False</tt> w przecziwnym przypadku.
		<pre>Przyk&#x0142;ady: > same_values plus times 2 3
           False
           > same_values plus times 2 2
           True
           > same_values equal not_equal 2 4
           False
</pre>

		<li> Prosz&#x0119; napisa&#x0107; funkcje <tt>odd n</tt> oraz <tt>even n</tt>, kt&#x00F3;re sprawdzaj&#x0105;, czy liczba naturalna <tt>n</tt> jest nieparzysta wzgl&#x0119;dnie parzysta.
		        Nale&#x017C;y u&#x017C;ywa&#x0107; wy&#x0142;&#x0105;cznie funkcje <tt>True</tt>, <tt>False</tt>, <tt>0</tt>, <tt>1</tt> oraz "<tt>-1</tt>".<br><br>


      <li>  Prosz&#x0119; napisa&#x0107; funkcje <tt>nwd a b</tt> oraz <tt>nww a b</tt>, kt&#x00F3;rych warto&#347;ciami s&#261; najwi&#281;kszy wsp&#243;lny dzielnik i najmniejsza wsp&#243;lna wielokrotno&#347;&#263;.
      <br><br>

      <li>  Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt>kwad a b c</tt>, kt&#243;ra obliczy miejsca zerowe r&#243;wnania kwadratowego <tt>ax^2 + bx + c</tt> dla danych <tt>a</tt>, <tt>b</tt> i <tt>c</tt>. <br><br>

       <li> Prosz&#x0119; napisa&#x0107; rekurencyjn&#x0105; oraz iteracyn&#x0105; funkcj&#x0119; <tt>fib n</tt>, kt&#x00F3;ra obliczy <tt>n</tt>-t&#x0105; liczb&#x0119; Fibonacci. <br><br>


      <li> Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt>Hanoi n</tt>, kt&#x00F3;ra rozwi&#x0105;zuje problem Wie&#x017C;y Hanoi dla <tt>n</tt> kr&#x0105;&#x017c;k&#x00F3;w. <br><br>

   <li>  Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt>Pascal n</tt>, kt&#243;rej warto&#347;ci&#261; jest <tt>n</tt>-ty wiersz tr&#243;jk&#261;ta Pascala.
         <br><br>

	 <li> Pot&#x0119;gowanie b^e mo&#x017C;na szybko wykona&#x0107; u&#x017C;ywaj&#x0105;c b^e = (b^(e/2))^2.
	 Prosz&#x0119; napisa&#x0107; rekurencyjn&#x0105; oraz iteracyjn&#x0105; funkcj&#x0119; <tt>exp b e</tt> na podstawie tej w&#x0142;a&#x015B;ciwo&#x015B;ci.
	 <br><br>

	 <li> Prosz&#x0119; napisa&#x0107; nast&#x0119;puj&#x0105;ce funkcje dla list: <br><br>
	 a) <tt>append l m</tt>, kt&#x00F3;ra konkatenuje listy <tt>l</tt> i <tt>m</tt>.<br><br>
	 b) <tt>member x </tt>, kt&#x00F3;ra sprawdza, czy <tt>x</tt> jest lementem listy <tt>l</tt> <br><br>
	 c)<tt>reverse l</tt>, kt&#x00F3;ra przewraca list&#x0119; <tt>l</tt>.<br><br>
	 d) <tt>last l</tt>, kt&#x00F3;ra znajduje ostatni element w liscie <tt>l</tt>.<br><br>
	 e) <tt>delete x l</tt>, kt&#x00F3;ra skasuje element <tt>x</tt> z listy <tt>l</tt>.<br><br>

	 <li> Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt> my_map f l</tt>, kt&#x00F3;rej warto&#x015B;ci&#x0105; jest lista warto&#x015B;ci <tt>f(e)</tt> dla wszystkich element&#x00F3;w <tt>e</tt> w liscie <tt>l</tt>. <br><br>

	 <li> a) Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt> permutation l</tt>, kt&#x00F3;rej warto&#x015B;ci&#x0105; jest lista wszystkich permutacji element&#x00F3;w listy <tt>l</tt>. <br><br>

	 b) Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt> PythagoreanTriple n</tt>, kt&#x00F3;rej warto&#x015B;ci&#x0105; jest lista warto&#x015B;ci <tt>(x,y,z)</tt> takie &#x017C;e <tt>x^2 + y^2 = z^2</tt> oraz <tt> 1 <= x,y,z <= n</tt>.
			 <br><br> 
			 <li>Prosz&#x0119; napisa&#x0107; funkcj&#x0119; <tt> Iter n f</tt> dla jednoargomentowej funkcji <tt>f</tt> i liczby naturalnej <tt>x</tt>. Warto&#x015B;ci&#x0105; funkcji jest funckj&#x0105;,  kt&#x00F3;ra obliczy <tt>f<sup>n</sup></tt>. 
<pre>Przyk&#x0142;ady: > iter 2 square 3
           81
           > let f = iter 2 square
           > f 5
           625
           > iter 0 square 7
           7 </pre>

			 <li>  Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119; <tt>filter pred l</tt>, kt&#x00F3;rej warto&#x015B;ci&#x0105; jest lista wszystkich element&#x00F3;w listy <tt>l</tt>, kt&#x00F3;re spe&#x0142;ni&#x0105; predykat <tt>pred</tt>.<br>
			 Jaki ma typ funkcja <tt>filter</tt>? <br><br>	 
			 <li> a) Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119;
			 <tt>foldr</tt> analogicznie do funkcji <tt> foldl</tt>.<br>
			 <br>			 b) Prosz&#x0119; zdefiniowa&#263; funkcje <tt>length</tt>, <tt>and</tt> (dla listy warto&#347;ci boole'owskich), <tt>sum</tt>, <tt>prod</tt>, <tt>map</tt> i <tt>reverse</tt> u&#380;ywaj&#261;c funkcje <tt>foldl</tt> i <tt>foldr</tt>.
			 <br><br>
			 <li>a) Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119;
			 <tt>map2 f l1 l2</tt>, kt&#x00F3;ra zastosuje dwuargumentow&#x0105; funkcj&#x0119; <tt>f</tt> do wszystkich element&#x00F3;w list <tt>l1</tt> i <tt>l2</tt>.
	<pre>&ensp;&ensp; Przyk&#322;ad: > map2 (+) [1,2,3] [8,9,10]
          &ensp;&emsp;[9,11,13]
</pre>
			 &ensp;&ensp;Jaki ma typ funkcja <tt>map2</tt>? <br><br>
			 
		b) Prosz&#x0119; przy pomocy <tt>map2</tt> (i innych kombinator&#x00F3;w) zrealizowa&#x0107; produkt wektorowy.	
		<br><br>
			 <li> Funkcja <tt>flatten :: [[a]] -> [a]</tt> transformuje list&#x0119; list do zwyk&#322;ej listy.
		<pre>Przyk&#322;ad: > flatten [[1,2,3], [8,9], [4,6]]
          [1,2,3,8,9,4,6]
</pre>
			 Prosz&#x0119; t&#261; funkcj&#x0119; napisa&#263; raz "r&#x0119;cznie" i raz u&#380;ywaj&#261;c funkcje <tt>fold</tt> z zadania 17.
			 <br><br>


			 <li> a) Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119; <tt>insertionsort :: [a] -> [a]</tt>.
			 <br><br>
			 b) Prosz&#x0119; zdefiniowa&#263; funkcj&#x0119; <tt>insertionsort :: (a -> a -> Bool) -> [a] -> [a]</tt>.
			 <br><br>
			 Prosz&#x0119; wykonywa&#263; a) i b) raz "r&#x0119;cznie" i raz u&#380;ywaj&#261;c funkcje <tt>fold</tt> z zadania 17.
			 <br><br>


			 <li> Prosz&#x0119; napisa&#263; funkcj&#x0119; <tt> dz</tt>, kt&#x00F3;ra realizuje schemat do rozwi&#261;zania problem&#x00F3;w typu "dziel i zwyci&#x0119;&#380;aj" (divide and conquer) na abstrakcyjnym po&#380;omie.
			 <tt>dz</tt> ma u&#380;ywa&#263; nast&#x0119;puj&#261;ce argumenty: <br><br>
			 <ol>
				 <li> <tt>test</tt>, kt&#x00F3;ry sprawdza czy przypadek jest triwialny
				 <li> <tt>koniec</tt>, kt&#x00F3;ry rozwi&#261;zuje triwialny przypadek
				 <li> <tt>dziel</tt>, kt&#x00F3;ry dzieli problem do podproblemow
				 <li> <tt>po&#322&#261;cz</tt>, kt&#x00F3;ry po&#322&#261;czy rozwi&#261;zania podproblem&#x00F3;w.
			 </ol>
			 <br>
			  U&#380;ywaj&#261;c funkcj&#x0119; <tt>dz</tt>
			  prosz&#x0119; zdefiniowa&#263; funkcj&#x0119; <tt>mergesort</tt> oraz mno&#x017C;enie wed&#x0142;ug Karatsuby.
			 <br><br>

			 <li> Prosz&#x0119; implementowa&#x0107; arytmetyk&#x0119; liczb zespolonych <br><br>
			 a) u&#x017C;ywaj&#x0105;c metod&#x0119; "mainfest types". <br><br>
			 b) u&#x017C;ywaj&#x0105;c metod&#x0119; "message passing". <br><br>


			 <li> Jaki typ maj&#x0105; nast&#x0119;puj&#x0105; wyra&#x017C;enia? <br>
			 <br>
			 a)  &nbsp; <tt> add  </tt> <br>
                         b)  &nbsp; <tt> add 37  </tt> <br>
			 c)  &nbsp; <tt> f 7 </tt> <br>
			 d)  &nbsp; <tt> \f -> f 7 </tt> <br>
                         e)  &nbsp; <tt> add (f x) (g x) </tt> <br>
			 f)  &nbsp; <tt> f 7 (g 'x') </tt> <br>
			 g)  &nbsp; <tt> \f -> f (g x) </tt> <br>
			 <br>

			 <li>Prosz&#x0119; obliczy&#263; mgu dla nast&#x0119;puj&#261;cych wyra&#380;e&#x0144;. <br>
			 <br> a) &nbsp; f(x,g(b)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   f(a,y) <br>
			 b) &nbsp; f(h(x,b),y) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  f(h(a,y),x) <br>
			 c) &nbsp; f(x,y) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(h(x,b),y) <br>
			 d) &nbsp; g(x,h(x,y),h(y,h(x,y))) &nbsp;&nbsp;&nbsp; g(x,y',h(z,y')) <br>
			 e) &nbsp; g(x,h(x,y),h(y,h(x,y))) &nbsp;&nbsp;&nbsp; g(x,y',h(y',z)) <br>
			 f) &nbsp; f(a,x,h(g(y))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(z,h(z),h(z')) <br><br>

			 <li> Prosz&#x0119; obliczyczy&#263; typ nast&#x0119;puj&#261;cych wyra&#380;e&#x0144;.
<pre>
a) \x -> 2 * x
b) \x -> x x
c) \f -> f x
d) append [] l     = l                        
   append (x:xs) l = x : (append xs l)   
e) fun []     = 0
   fun (x:xs) = 1 + (fun x) + (fun xs)
</pre>

			 <li> a) Prosz&#x0119; napisa&#263; funkcj&#x0119; <tt> pozycja</tt>, kt&#x00F3;ra znajduje pozycj&#x0119; elementu <tt>x</tt> w li&#x015B;cie <tt>l</tt>.
			 <br><br>
			 b) Prosz&#x0119; napisa&#263; funkcj&#x0119; <tt> drop</tt>, kt&#x00F3;ra eliminuje pierwsze <tt>n</tt> elementy z listy <tt>l</tt>.
			 <br><br>
			 Nale&#380;y u&#380;ywa&#263; typ <tt> Maybe a</tt>.
			 <br><br>

			 <li> Niech b&#x0119;dzie dany nast&#x0119;puj&#261;cy typ dla drzew binarnych.
			 <pre> data BinTree a = Leaf a | Node (BinTree a) (BinTree a)
</pre>
			 Prosz&#x0119; napisa&#263; modu&#x0142; <tt>BinTree</tt> z funkcjami <br><br>
			 &nbsp;&nbsp;a) <tt>heightBinTree</tt>, kt&#x00F3;ra obliczy g&#x0142;&#x0119;boko&#x015B;&#x0107; drzewa. <br><br>
			 &nbsp;&nbsp;b) <tt>sizeBinTree</tt>, kt&#x00F3;ra obliczy ilo&#x015B;&#x0107; w&#x0119;z&#x0142;&#x00F3;w w drzewie. <br><br>
			 &nbsp;&nbsp;c) <tt> sumBinTree</tt>, kt&#x00F3;ra obliczy sum&#x0119; element&#x00F3;w w drzewie. <br><br>
			 &nbsp;&nbsp;d) <tt> preBinTree</tt>, kt&#x00F3;rej warto&#x015B;ci&#261; jest lista element&#x00F3;w drzewa w porz&#261;ku prefiksowym.<br><br>
			 Nale&#380;y do tego u&#380;ywa&#263; nadaj&#261;ce si&#x0119; funkcje <tt>mapBinTree</tt> i <tt>foldBinTree</tt>. <br><br>

			 <li> Niech b&#x0119;dzie dany nast&#x0119;puj&#261;cy typ dla drzew og&#x00F3;lnych.
			 <pre> data Tree a = Node a [Tree a]
</pre>
			 Prosz&#x0119; napisa&#263; modu&#x0142; <tt>Tree</tt> z funkcjami <br><br>
			 &nbsp;&nbsp;a) <tt>sizeTree</tt>, kt&#x00F3;ra obliczy ilo&#x015B;&#x0107; w&#x0119;z&#x0142;&#x00F3;w w drzewie. <br><br>
			 &nbsp;&nbsp;b) <tt> sumTree</tt>, kt&#x00F3;ra obliczy sum&#x0119; element&#x00F3;w w drzewie. <br><br>
			 &nbsp;&nbsp;c) <tt> postTree</tt>, kt&#x00F3;rej warto&#x015B;ci&#261; jest lista element&#x00F3;w drzewa w porz&#261;ku postfiksowym.<br><br>
			 &nbsp;&nbsp;d) <tt> inTree</tt>, kt&#x00F3;rej warto&#x015B;ci&#261; jest lista element&#x00F3;w drzewa w porz&#261;ku infiksowym.<br><br>
			 Nale&#380;y do tego u&#380;ywa&#263; nadaj&#261;ce si&#x0119; funkcje <tt>mapTree</tt> i <tt>foldTree</tt>. <br><br>

			 <li> Prosz&#x0119; napisa&#263; modu&#x0142; <tt>Set</tt> z funkcjami <tt>member</tt>,
			  <tt>subset</tt>, <tt>union</tt>, <tt>intersection</tt> oraz <tt>delete</tt>.
			  <br><br>

			  <li> Prosz&#x0119; zdefiniowa&#263; drzewa z zbiorami na w&#x0119;z&#x0142;ach
			  przy pomocy modu&#x0142;&#x00F3;w <tt>Tree</tt> i <tt>Set</tt> oraz funkcje <br><br>
			  &nbsp;&nbsp;a) <tt> deleteTree</tt>, kt&#x00F3;ra eliminuje dany element <tt>x</tt> z ka&#x017C;dego zbioru w drzewa.<br><br>
			  &nbsp;&nbsp;b) <tt>unionTree</tt>, kt&#x00F3;rej warto&#x015B;ci&#261; jest
			  lista wszystkich element&#x00F3;w drzewa. <br><br>
			  &nbsp;&nbsp;c) <tt> allTree</tt>, kt&#x00F3;ra sprawdza, czy dany element <tt>x</tt> znajduje si&#x0119; w ka&#x017C;dym zbiorze w drzewa.
			  <br><br>

		 </ol>
 </body>
 </html>




