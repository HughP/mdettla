<html>
<head>
<META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=iso-8859-2">
<title>MazeGenSolve</title>
</head>
<body>
<p>
<applet width=490 height=420 code="MazeGenSolve.class">
  <param name="bgcolor" value="#FFFFFF">
</applet>
</p><p align="justify">
Labirynt generowany jest przez algorytm Depth-First Search. Traktujemy labirynt jako zbiór komórek, które na pocz±tku otoczone s± ¶cianami ze wszystkich stron. Nastêpnie algorytm sukcesywnie burzy ¶ciany miêdzy komórkami, stosuj±c strategiê zach³ann±. Zaczynamy od dowolnie wybranej komórki. Nastêpnie, spo¶ród s±siednich komórek, w których stoj± jeszcze wszystkie cztery ¶ciany, wybieramy jedn± losowo i przechodzimy do niej burz±c po drodze ¶cianê, po czym powtarzamy proces. Je¶li nie ma takiej komórki, cofamy siê. Algorytm jest szybki, ale wymaga dodatkowej pamiêci na zapamiêtanie poprzednich pozycji (których jest nie wiêcej ni¿ komórek). Najlepiej u¿yæ do tego stosu (struktury danych typu LIFO).
</p><p align="justify">
W wyniku powstaje labirynt o w³asno¶ci perfect, lub inaczej simply connected. Oznacza to, ¿e z dowolnego punktu w labiryncie istnieje dok³adnie jedna ¶cie¿ka do ka¿dego innego punktu. Istnieje wiêc tylko jedno rozwi±zanie. Nie ma ¿adnych zamkniêtych pêtli ani niedostêpnych rejonów, a wszystkie ¶ciany s± po³±czone ze sob±. Taki labirynt mo¿na te¿ zdefiniowaæ jako minimalne drzewo spinaj±ce na zbiorze komórek.
</p><p align="justify">
Rozwi±zanie znajduje algorytm Tremaux. Dzia³a on z perspektywy osoby znajduj±cej siê wewn±trz labiryntu. Po doj¶ciu do rozwidlenia, zaznaczamy ¶cie¿kê z której przyszli¶my (kolor ¿ó³ty) i wybieramy wolny korytarz, w którym jeszcze nie byli¶my. Je¶li nie ma takiego, wybieramy jeden z ju¿ odwiedzonych i zaznaczamy go drugi raz (kolor niebieski). Je¶li wszystkie korytarze na rozwidleniu zaznaczyli¶my ju¿ dwa razy, algorytm koñczy siê. Algorytm gwarantuje znalezienie rozwi±zania dla dowolnego labiryntu, ale nie zawsze jest to rozwi±zanie najkrótsze (oczywi¶cie w labiryntach simply connected nie stanowi to problemu). Po jego zakoñczeniu albo dojdziemy do wyj¶cia, albo wrócimy do punktu z którego wystartowali¶my, przeszed³szy ca³y labirynt.
</p><p align="justify">
Innym prostym sposobem na znalezienie wyj¶cia jest zasada "id¼, trzymaj±c siê ca³y czas jednej ¶ciany" (lub inaczej: skrêcaj zawsze w prawo, lub zawsze w lewo). Jednak ta metoda nie gwarantuje znalezienia rozwi±zania, je¶li labirynt nie jest simply connected.
</p><p>
<a href="MazeGenSolve.java">Kod ¼ród³owy (Java)</a>
</p>
</body>
</html>
