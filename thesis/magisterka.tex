\documentclass[brudnopis]{xmgr}

%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Minion Pro}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Myriad Pro}
%\setmonofont[Scale=0.75]{Monaco}

% Opcjonalnie identyfikator dokumentu
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Michał Dettlaff}
\nralbumu {164\,622}
\email    {walenty@szczesny.com.pl}

\title    {Zastosowanie algorytmów genetycznych w projektowaniu optymalnego układu klawiatury}
\date     {2011}
\miejsce  {Gdańsk}

\opiekun  {prof. zw. dr hab. inż. Sławomir Wierzchoń}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}

\begin{document}

\begin{abstract}
  Projektowanie optymalnego, ergonomicznego układu klawiatury można potraktować jako problem optymalizacyjny, do rozwiązania którego można zastosować znane metaheurystyki. W poniższej pracy wykorzystany jest do tego celu algorytm genetyczny, w którym genotyp stanowi układ klawiszy zakodowany jako permutacja, a funkcja przystosowania odzwierciedla ilość pracy potrzebną do przepisania tekstu za pomocą danego układu. W wyniku zostają utworzone układy klawiatury przystosowane do pisania w języku polskim oraz angielskim, które następnie są porównane ze standardowymi układami klawiatury (QWERTY, Dvorak), zaprojektowanymi bez udziału komputera.
\end{abstract}
\keywords{
  algorytmy, genetyczne, Dvorak, QWERTY, optymalizacja
}

% tytuł i spis treści
\maketitle
%
% wstęp
\introduction

Standardowy układ klawiatury (rys. 1), mimo swojej wszechobecności oraz pozostawania w użyciu od ponad 100 lat, jest pod wieloma względami nieoptymalny. Układ ten nazywany jest układem QWERTY (od pierwszych liter w górnym rzędzie w jego amerykańskiej wersji) lub układem Scholesa i został zaprojektowany w latach 70 XIX wieku przez Charles'a Lethama Sholesa. QWERTY zastąpił używany wcześniej układ alfabetyczny i miał na celu zapobieganie zacinaniu się mechanizmu maszyny do pisania, jeżeli użytkownik pisał zbyt szybko~\cite{Norman:1988:DOET}. Z tego względu, litery które często występowały obok siebie w języku angielskim, takie jak \emph{i} oraz \emph{e}, zostały umieszczone po przeciwnych stronach klawiatury. Dzięki temu, belki na których znajdowały się klawisze nie zderzały się ze sobą, co zmniejszało prawdopodobieństwo zacięcia się. Mimo że problem zacinania się maszyny został szybko wyeliminowany i to jeszcze na długo przed nadejściem klawiatury komputerowej, układ klawiatury QWERTY pozostaje w powszechnym użyciu aż do dzisiaj i stanowi de facto standard.

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/qwerty}
\caption{Standardowy układ klawiatury QWERTY}
\source{Opracowanie własne}
\end{figure}

Spośród układów alternatywnych wobec QWERTY największą popularnością cieszy się klawiatura Dvoraka (Dvorak Simplified Keyboard). Została ona zaprojektowana w 1936 r. przez dr Augusta Dvoraka. W przeciwieństwie do QWERTY, podczas jej projektowania nie były już brane pod uwagę ograniczenia mechaniczne maszyn do pisania, ze względu na postępy w ich produkcji. Głównym celem było natomiast umożliwienie efektywnego pisania oraz łatwość nauki. W tym celu zostały wzięte pod uwagę takie czynniki jak częstotliwości występowania liter oraz poziom wykorzystania najłatwiej dostępnego, środkowego rzędu klawiszy. Dla przykładu, za pomocą samego środkowego rzędu klawiatury Dvoraka można napisać około 400 słów w języku angielskim, natomiast układ QWERTY pozwala w analogiczny sposób napisać tylko około 100 słów~\cite{Call:2005:CME}. Klawiatura Dvoraka jest łatwiejsza w nauce i pozwala na około 10\% szybsze pisanie~\cite{Norman:1988:DOET}.

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/dvorak}
\caption{Układ klawiatury Dvorak Simplified Keyboard}
\source{Opracowanie własne}
\end{figure}

Wspomniane układy klawiatury zostały zaprojektowane ręcznie, bez udziału komputera. Podjęto też wiele prób rozwiązania problemu szukania optymalnego klawiatury (Keyboard Arrangement Problem - KAP) z użyciem algorytmów ewolucyjnych oraz innych metaheurystyk. Wagner \cite{AntColony:2002:ACO} wygenerował układy klawiatury dla języka angielskiego, niemieckiego oraz francuskiego, stosując algorytm mrówkowy (Ant Colony Optimization) oraz szereg kryteriów ergonomicznych. Yin oraz Su \cite{Swarm:2011:CSOGKAP} sformułowali problem ogólnie dla różnych typów klawiatur (General Keyboard Arrangement Problem - GKAP) oraz zastosowali do jego rozwiązania algorytm optymalizacji rojowej (Cyber Swarm Optimization). Deshwal oraz Deb \cite{Hindi} zaproponowali nowy projekt klawiatury dla języka Hindi, stosując algorytm genetyczny z reprezentacją układu klawiszy jako czterowymiarowej tablicy.

Podobne algorytmy stosowano również dla niestandardowych klawiatur, na przykład w telefonach komórkowych, na których pisze się z użyciem jednego lub dwóch palców~\cite{Li2006695}. Niniejsza praca dotyczy KAP rozumianego jako poszukiwanie optymalnego układu klawiszy dla standardowej klawiatury, zoptymalizowanego pod kątem techniki pisania bezwzrokowego (touchtyping). Pisanie bezwzrokowe zobrazowane jest na poniższej ilustracji.

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/touchtyping}
\caption{Użycie palców w pisaniu bezwzrokowym}
\source{Opracowanie własne}
\end{figure}

W technice bezwzrokowej, w domyślnej pozycji palce lewej ręki znajdować się powinny nad klawiszami $asdf$, a prawej nad $jkl;$. Po wciśnięciu któregoś z pozostałych klawiszy, palec powiniem powrócić na swoją standardową pozycję w środkowym rzędzie (tzw. home row). Kciuki zajmują się altem i spacją. Kolorami oznaczono, którymi palcami powinno się uderzać poszczególne klawisze, na przykład: lewy serdeczny wciska $x$, $s$, $w$ i $3$, a prawy wskazujący $n$, $m$, $h$, $j$, $y$ itd.


\chapter{Algorytmy genetyczne}

Inspiracją dla algorytmów genetycznych jest ewolucja naturalna, w szczególności mechanizmy dziedzczenia oraz doboru naturalnego.

Algorytmy genetyczne należą do metod populacyjnych, w których operujemy na pewnym zmieniającym się zbiorze (populacji) rozwiązań. Daje to znaczącą przewagę nad prostszymi algorytmami wspinaczkowymi, w których zachowujemy tylko jedno rozwiązanie w danym momencie. Zachowywanie populacji rozwiązań zmniejsza prawdopodobieństwo przedwczesnej zbieżności w lokalnym optimum, zwiększając możliwości eksploracyjne algorytmu. Inne skrajne podejście, w którym przeszukujemy jednocześnie całą przestrzeń rozwiązań, jest również mało skuteczne ze względu na zbyt duży rozmiar tej przestrzeni dla większości interesujących problemów. Algorytm genetyczny unika tego problemu poprzez dobranie rozmiaru populacji znacznie mniejszego od rozmiaru całej przestrzeni poszukiwań.

Schemat algorytmu genetycznego można przedstawić za pomocą następującego pseudokodu:

\noindent
\texttt{i := 0\newline
Zainicjuj populację początkową P(i)\newline
Oceń osobniki z populacji początkowej\newline
Powtarzaj dopóki nie jest spełniony warunek zakończenia:\newline
\indent i := i + 1\newline
\indent Wybierz osobniki z P(i-1) i utwórz nową populację P(i)\newline
\indent Zmień osobniki z P(i)\newline
\indent Oceń osobniki z P(i)\newline
}

Warunkiem zakończenia może być upłynięcie określonej ilości iteracji, lub znalezienie rozwiązania które jest wystarczająco bliskie optimum.

Algorytm genetyczny operuje na osobnikach w zakodowanej postaci, którą najczęściej nazywa się chromosomem. Każdy chromosom reprezentuje potencjalne rozwiązanie zadania. W klasycznych algorytmach genetycznych, chromosom ma postać ciągu bitów o stałej długości.

Pierwszym krokiem algorytmu jest wygenerowanie populacji początkowej. Powinna się ona cechować możliwie dużą różnorodnością, dlatego najczęściej stosowaną metodą jej tworzenia jest generowanie chromosomów w sposób losowy. Czasem w populacji początkowej umieszcza się też specjalnie przygotowane osobniki, o których spodziewamy się że leżą w pobliżu optimum.

Wybór osobników do nowo tworzonych populacji jest procesem analogicznym do doboru naturalnego. W ujęciu Karola Darwina, największe szanse przetrwania mają osobniki najlepiej przystosowane do środowiska. Wpływ środowiska jest w algorytmach genetycznych modelowany przez funkcję oceny lub funkcję przystosowania. Ponieważ problemy optymalizacji zwykle definiuje się w kategoriach poszukiwania minimum, przyjmiemy konwencję zgodnie z którą mniejsza wartość funkcji oceny oznacza lepsze przystosowanie. Dlatego też w operacji wyboru (selekcji) osobników do nowej populacji powinny być faworyzowane osobniki o niższej wartości funkcji przystosowania.

Jedną z najprostszych implementacji operacji selekcji jest selekcja proporcjonalna, w której osobniki wybierane są z prawdopodobieństwej proporcjonalnym do wartości funkcji przystosowania. Wadą selekcji proporcjonalnej jest tendencja do zbyt szybkiego zdominowania populacji przez najbardziej przystosowane osobniki. Dlatego zaproponowano wiele alternatywnych implementacji operatora selekcji, takie jak selekcja rangowa, turniejowa, lub podwójna turniejowa.

Sam operator selekcji nie jest wystarczającym warunkiem do tego, aby wartość funkcji oceny poprawiała się w kolejnych populacjach. Potrzebny jest operator wprowadzający zmienność oraz innowacje do populacji. W klasycznych algorytmach genetycznych, służą do tego operacje mutacji oraz krzyżowania.

Operacja mutacji powinna powodować jedynie niewielką zmianę w położeniu rozwiązania w pejzażu dostosowań. To znaczy, niewielka modyfikacja chromosomu powinna wpływać w niewielkim stopniu na wartość funkcji przystosowania. W klasycznym algorytmie genetycznym, mutacja polega na losowej zmianie elementu chromosomu z jednakowym (niewielkim) prawdopodobieństwem na wartość przeciwną (z jedynki na zero i na odwrót) \cite{Goldberg:1998:AGZ}.

Zaletą klasycznych algorytmów genetycznych jest fakt, że uniwersalna reprezentacja chromosomów jako ciągów bitów pozwala na ponowne wykorzystanie tych samych operatorów mutacji oraz krzyżowania. Jedyne co trzeba zrobić aby zastosować algorytm genetyczny do nowego problemu, jest zaimplementowanie funkcji oceny oraz zakodowanie potencjalnych rozwiązań w postaci ciągu bitów. Takie podejście jest jednak problematyczne dla wielu zastosowań. Mutacja oraz krzyżowanie mogą prowadzić do powstawania osobników które stanowią rozwiązanie nieprawidłowe, które muszą zostać odrzucone.

Jednym z prostszych operatorów krzyżowania dla binarnej reprezentacji chromosomu jest krzyżowanie punktowe. W krzyżowaniu punktowym, wybieramy na chromosomie losowo punkt przecięcia. Aby utworzyć pierwszego potomka, kopiujemy geny leżące na lewo od punktu przecięcia z jednego rodzica, a geny leżące na prawo z drugiego rodzica. Drugi potomek powstaje analogicznie poprzez skopiowanie najpierw prawej, a następnie lewej strony. Przykładowo, w wyniku zastosowania krzyżowania punktowego z punktem przecięcia między drugą i trzecią pozycją do pary rodziców:
$$(a_1 a_2 a_3 a_4 a_5), (b_1 b_2 b_3 b_4 b_5)$$

otrzymamy następujące osobniki potomne:
$$(a_1 a_2 b_3 b_4 b_5), (b_1 b_2 a_3 a_4 a_5)$$

Wadą krzyżowania punktowego jest fakt, że geny leżące na sąsiadujących pozycjach będą rozdzielane z większym prawdopodobieństwem od genów leżących na bardziej odległych pozycjach. Jednym ze sposobów na zniwelowanie tego problemu jest zwiększenie liczby punktów przecięcia, w wyniku czego otrzymamy krzyżowanie wielopunktowe.

Algorytmy genetyczne znajdują szerokie zastosowania w zadaniach przeszukiwania oraz optymalizacji. Należą do nich między innymi: wytyczanie trasy połączeń kablowych, harmonogramowanie, sterowanie adaptacyjne, rozgrywanie gier, modelowanie poznawcze, zadania transportowe, zadanie komiwojażera, sterowanie optymalne, optymalizacja obsługi zapytań w bazach danych itp.\cite{Michalewicz:2003:AGSDPE}


\chapter{Opis algorytmu}


\section{Reprezentacja genotypu}

Układ klawiatury można zakodować jako ciąg binarny, opisując każdy klawisz za pomocą określonej ilości bitów. Niestety, stosowanie klasycznych operatorów genetycznych spowoduje, że zdecydowana większość powstałych w ten sposób rozwiązań będzie nieprawidłowych. Przykładowo, jeżeli użyjemy trzech bitów do opisania każdego klawisza klawiatury o 40 klawiszach, tylko jedna z każdych 1016 dowolnie wybranych struktur 120-bitowych jest strukturą o właściwej konfiguracji klawiszy~\cite{GloverKey}.

W związku z powyższym, zastosowana zostanie permutacyjna reprezentacja genotypu oraz specjalnie dla niej dostosowane operatory mutacji oraz krzyżowania. Układ klawiatury reprezentowany jest przez permutację 30 klawiszy. 26 klawiszy oznaczanych jest literami alfabetu łacińskiego A-Z, a pozostałe odpowiadają znakom ",", ".", "?" oraz ";". Wynika z tego, że liczba wszystkich możliwych układów klawiatury wynosi $$ 30! \simeq 2.65 * 10^{32} $$ co stanowi rozmiar przestrzeni poszukiwań na której będzie działał algorytm genetyczny. Zbiór wszystkich znaków wchodzących w skład permutacji oznaczymy jako $ A $.

Klawisze podzielone są na trzy grupy, gdzie pierwsze 10 oznacza klawisze górnego rzędu klawiatury, następne 10 klawisze rzędu środkowego, a ostatnie 10 - dolnego rzędu.

Dla przykładu, układ klawiatury QWERTY jest reprezentowany przez następującą permutację:
$$ (qwertyuiopasdfghjkl;zxcvbnm,.?) $$


\section{Funkcja przystosowania}

Naszym celem jest znalezienie układu klawiatury, który przyczyni się do zwiększenia prędkości pisania oraz zminimalizowania zmęczenia palców użytkownika. Inne pożądane cechy to minimalizowanie ilości błędów oraz łatwość nauki danego układu klawiatury. Dlatego też te cele będą brane pod uwagę podczas projektowania funkcji przystosowania algorytmu genetycznego.

W kolejnych podrozdziałach zostaną opisane kryteria, które składają się na funkcję przystosowania. Ostateczna postać funkcji przystosowania jest sumą ważoną wyników z poszczególnych kryteriów.

Do obliczania oceny układu klawiatury wykorzystywane są zbiory tekstów, stanowiących możliwie reprezentatywną próbkę z danego języka. Wynikowy układ powinien być jak najlepiej przystosowany do przepisywania podanego tekstu, dlatego użyte zostaną osobne zbiory tekstów dla języka polskiego oraz angielskiego. Naiwnym sposobem na obliczenie przystosowania byłaby symulacja przepisywania tekstu, wymagająca analizy całości tekstu za każdym razem od nowa podczas obliczania funkcji przystosowania. Takie podejście jest jednak zbyt kosztowne obliczeniowo, ponieważ złożoność funkcji przystosowania wyniosłaby $ O(n) $, gdzie $ n $ stanowiące długość tekstu byłoby wartością rzędu $ 10^5 $ lub $ 10^6 $.

Z tego powodu funkcja przystosowania nie będzie obliczana na podstawie oryginalnego tekstu, ale jego cech statystycznych, które będą obliczane tylko raz przed uruchomieniem algorytmu. W ten sposób czas obliczania funkcji przystosowania nie będzie zależny od długości tekstu (jego złożoność wyniesie $ O(1) $). Cechy statystyczne tekstu zostaną opisane za pomocą dwóch funkcji:
$$ f_m : M \rightarrow \mathrm{R} $$
$$ f_d : D \rightarrow \mathrm{R} $$

Dziedzinę funkcji $ f_m $ będziemy określać jako zbiór monografów $ M $ (pojedynczych znaków wchodzących w skład genotypu), a dziedzinę funkcji $ f_d $ jako zbiór diagrafów $ D $ (wszystkich możliwych par znaków).
$$ M = \{ a : a \in A \} $$
$$ D = \{ ab : a \in A, b \in A \} $$

$ f_m $ opisuje częstotliwości występowania monografów w zbiorze tekstów, a $ f_d $ częstotliwości występowania diagrafów. Przez częstotliwość występowania rozumiemy procentowy udział ilości wystąpień danego monografu (diagrafu) w sumie ilości wystąpień wszystkich monografów (diagrafów).


\subsection{Użycie palców}

Pierwszym czynnikiem branym pod uwagę będzie rozkład pracy na poszczególne palce. Chcemy, aby najczęściej używane były najsilniejsze i najdłuższe palce, a najmniej używane palce najsłabsze.

W tym celu zdefiniujemy optymalny rozkład użycia, który podajemy w oparciu o~\cite{AntColony:2002:ACO}. $f^{opt}_1$ do $f^{opt}_4$ oznaczają udział palców lewej ręki w przepisywaniu tekstu, od małego palca do wskazującego, natomiast $f^{opt}_5$ do $f^{opt}_8$ analogicznie udział palców prawej ręki, od wskazującego do małego.\newline

\begin{tabular}{ c | c | c | c | c | c | c | c }
  $f^{opt}_1$ & $f^{opt}_2$ & $f^{opt}_3$ & $f^{opt}_4$ & $f^{opt}_5$ & $f^{opt}_6$ & $f^{opt}_7$ & $f^{opt}_8$ \\
  \hline
  4.4\% & 12.3\% & 15.8\% & 17.5\% & 17.5\% & 15.8\% & 12.3\% & 4.4\% \\
\end{tabular}\newline

Czynnik funkcji przystosowania odpowiadający użyciu palców przyjmnie następującą postać, odzwierciedlającą rozbieżność pomiędzy rozkładem otrzymanym a optymalnym:
$$ p_{finger} = \sum\limits_{i = 1}^{8} (f_i^{opt} - f_i)^2 $$


\subsection{Użycie rzędów klawiszy}

Podczas pisania techniką bezwzrokową (touchtyping), pozycją domyślną jest utrzymywanie palców nad klawiszami w środkowym rzędzie (tzw. home row). Z tego powodu optymalny układ klawiatury powinien zawierać najczęściej używane znaki w środkowym rzędzie. Znaki z górnego oraz dolnego rzędu wymagają ruchu palca z domyślnego rzędu środkowego, a następnie powrotu na pozycję domyślną, co jest mniej optymalne. Klawisze z górnego rzędu są przy tym nieco łatwiej dostępne od tych z dolnego.

Górny, środkowy oraz dolny rząd klawiszy oznaczymy odpowiednio jako: $R_1$, $R_2$, $R_3$. Jako optymalny rozkład częstotliwości użycia poszczególnych rzędów przyjmiemy rozkład układu klawiatury, w którym 10 najczęściej używanych klawiszy należy do $R_1$, 10 kolejnych do $R_2$, a 10 najmniej używanych klawiszy do $R_3$. Częstotliwości użycia obliczane są na podstawie stosowanego zbioru tekstów.

Przykładowe wartości: $f_{R_1} = 50\%$, $f_{R_2} = 35\%$, $f_{R_3} = 15\%$

Biorąc powyższe kryteria pod uwagę, czynnik funkcji przystosowania dotyczący położenia znaku w danym rzędzie przyjmie następującą postać:
$$ p_{row} = \sum\limits_{i = 1}^{3} (f_{R_i}^{opt} - f_{R_i})^2 $$


\subsection{Alternacja rąk}

Czynnikiem sprzyjającym szybkiemu i komfortowemu pisaniu jest unikanie pisania kolejnych znaków tą samą ręką. Jest to jedna z głównych zasad która została zastosowana przy projektowaniu klawiatury Dvoraka, gdzie w tym celu wszystkie samogłoski umieszczono z lewej strony klawiatury (ponieważ w języku angielskim samogłoski najczęściej nie występują obok siebie).

Liczbową reprezentacją tej zasady będzie następujące wyrażenie:

$$ p_{hand\_alter} = \sum\limits_{f \in f_{sh}} f $$

Gdzie $ f_{sh} \in f_d $ oznacza zbiór częstotliwości występowania diagrafów pisanych tą samą ręką.


\subsection{Alternacja palców}

Podobnie jak w poprzednim punkcie, nie jest korzystne pisanie kolejnych znaków tym samym palcem. Dodatkowe utrudnienie stanowi sytuacja, w której ten sam palec musi przebyć większą odległość. Dlatego też częstotliwość występowania diagrafów zostanie dodatkowo pomnożona przez współczynnik odległości $dist$.
$$ p_{finger\_alter} = \sum\limits_{d \in D'} f_d dist(d) $$

\noindent
gdzie zbiór $ D' \in D $ oznacza zbiór diagrafów które pisane są tym samym palcem, a $f_d$ oznacza częstotliwości występowania tych diagrafów.\newline

Jako odległość $dist$ zostanie przyjęta odległość Manhattan:
$$ dist(d) = |c_2 - c_1| + |r_2 - r_1| $$

gdzie $c_1$ oraz $r_1$ stanowią współrzędne odpowiednio rzędu i kolumny pierwszego znaku z diagrafu $d$, a $c_2$ oraz $r_2$ współrzędne drugiego znaku diagrafu $d$.


\subsection{Duże ruchy palcami tej samej ręki}

W wypadku użycia tej samej ręki do naciśnięcia kolejno dwóch klawiszy, należy unikać sytuacji w której klawisze te znajdują się daleko od siebie. Dlatego też podczas obliczania tego współczynnika będą brane pod uwagę diagrafy wpisywane tą samą ręką, ale przy użyciu różnych palców, gdzie pionowa odległość jest większa niż jeden rząd (zbiór ten oznaczymy jako $ D' \in D $). W zależność od tego które palce zostaną użyte, zostaną przypisane odpowiednie wagi zgodnie z poniższą tabelą~\cite{AntColony:2002:ACO}.\newline

\begin{tabular}{ c | c | c | c | c | c }
  & wskazujący & środkowy & serdeczny & mały \\
  \hline
  wskazujący & 0 & 5 & 8 & 6 \\
  środkowy & 5 & 0 & 9 & 7 \\
  serdeczny & 8 & 9 & 0 & 10 \\
  mały & 6 & 7 & 10 & 0 \\
\end{tabular}\newline\newline

Wzór przyjmie postać:
$$ p_{step} = \sum\limits_{d \in D'} K(d) f_d $$

gdzie $K(d)$ oznacza współczynnik wagowy przypisany zgodnie z tabelą.


\subsection{Inboard stroke flow}

Dla diagrafów wpisywanych z użyciem tej samej ręki, bardziej korzystny jest kierunek prowadzący do środka, czyli w kierunku od małego palca do wskazującego (tzw. inboard stroke flow). Czynnikowi temu będzie odpowiadał następujący wzór, w którym sumujemy częstotliwości występowania diagrafów prowadzących mniej korzystnym kierunku (zbiór takich diagrafów oznaczymy poniżej jako $ D' \in D $):

$$ p_{isf} = \sum\limits_{d \in D'} f_d $$


\subsection{Użycie rąk}

Wysiłek związany z pisaniem powinien być rozłożony proporcjonalnie na obie ręce. Przyjmiemy tutaj, że idealny rozkład powinien być równy 50\% dla każdej ręki. Czynnik ten wyniesie zatem:
$$ p_{hand\_usage} = (f_{left} - 50\%)^2 + (f_{right} - 50\%)^2 $$

gdzie $f_{left}$ oznacza procentowy udział znaków wpisanych lewą ręką, a $f_{right}$ analogicznie prawą ręką.\newline\newline


\noindent Ostatecznie, funkcja przystosowania przyjmie postać:
$$ p = p_{finger} w_{finger} + p_{row} w_{row} + p_{hand\_alter} w_{hand\_alter} + p_{finger\_alter} w_{finger\_alter} + $$
$$ p_{step} w_{step} + p_{isf} w_{isf} + p_{hand\_usage} w_{hand\_usage} $$

\noindent
gdzie \emph{w} są wagami poszczególnych składowych. Wagi dobrane są eksperymentalnie w ten sposób, aby poszczególne czynniki miały zbliżony wpływ na ostateczną wartość funkcji przystosowania.


\section{Operatory krzyżowania}

\subsection{Cycle Crossover (CX)}

Istotną cechą jaką powinien posiadać algorytm krzyżowania do naszych zastosowań, jest zachowywanie absolutnych pozycji genów w genotypie. Cechę tę posiada operator Cycle Crossover~\cite{Operators:2000:TSP}. Średnio połowa absolutnych pozycji genów z obu rodziców zostaje w nim zachowana.

W krzyżowaniu Cycle Crossover, wybieramy losowy gen z losowo wybranego rodzica i umieszczamy go na tej samej pozycji w genotypie potomnym. Procedura ta musi być odpowiednio zmodyfikowana, aby zapewnić że genotyp potomny stanowi prawidłową permutację (a zatem prawidłowy układ klawiatury).

Jeżeli okazuje się, że danego genu z genotypu rodzica nie można umieścić w genotypie potomnym, zostaje wybrany gen drugiego rodzica. Jeżeli ten gen również nie może zostać wybrany, zostaje wybrany losowo jeden z pozostałych genów, które są dozwolone. Kolejne geny wybrane z jednego rodzica tworzą jeden cykl, stąd nazwa algorytmu.

Rozważmy przykład. Niech dane będą następujące osobniki rodzicielskie:
$$ (1 2 3 4 5 6 7 8) $$
$$ (2 4 6 8 7 5 3 1) $$

Na początku musimy wybrać pozycję, z której będzie pochodził pierwszy gen. Załóżmy, że będzie to pierwsza. Na pierwszą pozycję genotypu potomka możemy teraz wybrać $1$ lub $2$, w zależności od tego który rodzic zostanie wybrany. Niech będzie to rodzic pierwszy.
$$ (1 * * * * * * *) $$

Rozpatrzmy teraz gen na ostatniej pozycji. Możemy wybrać $1$ lub $8$, ale jeżeli wybierzemy $1$, wynikowy genotyp nie będzie już prawidłową permutacją. Dlatego wybieramy $8$.
$$ (1 * * * * * * 8) $$

Geny na czwartej oraz drugiej pozycji muszą również zostać wybrane z pierwszego rodzica, aby uniknąć wybrania po raz kolejny tych samych genów.
$$ (1 2 * 4 * * * 8) $$

Ponieważ wszystkie do tej pory wybrane geny należą do tego samego rodzica, możemy powiedzieć że tworzą one cykl. Rozpatrzmy teraz geny na trzeciej pozycji. Możemy wybrać dowolny z nich ($3$ lub $6$). Jeżeli wybierzemy gen z drugiego rodzica ($6$), wtedy geny na piątej, szóstej i siódmej pozycji również mogą pochodzić z drugiego rodzica, tworząc drugi cykl. Ostatecznie, otrzymujemy następującego osobnika potomnego:
$$ (1 2 6 4 7 5 3 8) $$


\subsection{Partially mapped crossover (PMX)}

Podobnie jak Cycle Crossover, Partially mapped crossover zachowuje częściowo absolutne pozycje genów rodzicielskich. Fragment genotypu jednego z rodziców jest przepisywany na potomka, a pozostała część genotypu jest tworzona na podstawie mapowań.

Sposób działania tego operatora jest następujący:

[przykład]


\section{Operatory mutacji}

\subsection{Exchange Mutation (EM)}

W operatorze Exchange Mutation wybieramy losowo dwa elementy permutacji, po czym zamieniamy je miejscami. Metoda ta znana jest też jako Swap Mutation lub Reciprocal Exchange Mutation. Na przykład, jeżeli w permutacji $ (a b c d e f g h) $ wybierzemy element drugi i piąty, otrzymamy w efekcie:
$$ (a \textit{\textbf{e}} c d \textit{\textbf{b}} f g h) $$

\subsection{Displacement Mutation (DM)}

Pierwszym krokiem w metodzie Displacement Mutation jest wybranie losowego odcinka permutacji. Załóżmy, że zaczęliśmy od permutacji $ (a b c d e f g h) $ i wybraliśmy odcinek $ (d e f g) $. Następnie, należy usunąć wybrany odcinek z permutacji i umieścić go w niej ponownie na losowo wybranej pozycji. W naszym przykładzie, po jego usunięciu permutacja przyjmie postać:
$$ (a b c h) $$

Załóżmy, że w tak powstałej permutacji wylosowano pozycję pomiędzy elementami $a$ oraz $b$. W takim wypadku, ostateczny wynik mutacji przyjmie następującą postać:
$$ (a \textit{\textbf{defg}} b c h) $$


\section{Selekcja}

Zastosowana zostanie tzw. selekcja turniejowa. Jest to bardzo prosty algorytm selekcji, będący jednocześnie jednym z najpopularniejszych~\cite{Luke2009Metaheuristics}.

W selekcji turniejowej, wybieramy najlepiej przystosowanego osobnika spośród losowo wybranego podzbioru populacji, bez powtórzeń. Algorytm można dostosować poprzez zmianę parametru $t$, czyli rozmiaru wybieranego podzbioru. Innymi zaletami algorytmu są jego prostota oraz niezależność od szczegółów implementacji funkcji przynależności.

Pseudokod:\newline

\noindent
\texttt{WEJŚCIE: populacja, t - rozmiar turnieju\newline
Best := wybierz bez zwracania osobnika z populacji\newline
Powtarzaj t - 1 razy:\newline
\indent Next := wybierz bez zwracania osobnika z populacji\newline
\indent jeżeli Next ma korzystniejszą wartość przystosowania niż Best:\newline
\indent\indent Best := Next\newline
zwróć Best\newline
}

Najczęściej wybieraną wartością parametru $t$ w przypadku algorytmów genetycznych jest 2~\cite{Luke2009Metaheuristics}, dlatego też taka wartość zostanie zastosowana do problemu znajdowania optymalnego układu klawiatury.


\section{Algorytm}

Zastosowany algorym można opisać za pomocą następującego pseudokodu:\newline

\noindent
\texttt{Oblicz cechy statystyczne zbioru tekstów\newline
Zainicjuj początkową populację losowo utworzonymi osobnikami\newline
Powtarzaj zadaną ilość pokoleń:\newline
\indent Utwórz nową, pustą populację osobników\newline
\indent Dopóki wielkość nowej populacji jest mniejsza od poprzedniej:\newline
\indent\indent oblicz przystosowanie osobników istniejącej populacji\newline
\indent\indent wybierz parę osobników za pomocą operatora selekcji\newline
\indent\indent zastosuj z zadanym prawdopodobieństwem operację krzyżowania\newline
\indent\indent wobec wybranych osobników\newline
\indent\indent zastosuj z zadanym prawdopodobieństwem operację mutacji\newline
\indent\indent wobec wybranych osobników\newline
\indent\indent dodaj osobniki do nowej populacji\newline
}

W celu przyspieszenia obliczeń, funkcja przystosowania obliczania jest współbieżnie. Jest to możliwe ponieważ obliczanie funkcji przystosowania dla jednego osobnika jest operacją niezależną od obliczania jej dla pozostałych osobników. Dlatego też populacja dzielona jest na \emph{n} części, gdzie \emph{n} jest równa ilości rdzeni procesora, i funkcja przystosowania dla każdej części obliczana jest przez osobny wątek.


\chapter{Wyniki i ich analiza}

Algorytm został uruchomiony na serwerze z 8-rdzeniowym procesorem Intel Xeon 3.00 Ghz oraz 32 GB pamięci RAM.

Rozmiar populacji został ustalony na $100$. Algorytm został uruchomiony dla $100$ iteracji.

\section{Wyniki dla języka angielskiego}

Do obliczania oceny układów klawiatury został użyty zbiór tekstów powstały przez konkatenację 10 najpopularniejszych książek w języku angielskim ze strony:\newline{\tt www.gutenberg.org}.

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/fitness_time_en}
\caption{Ewolucja maksymalnego przystosowania w populacji}
\end{figure}

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/best_en}
\caption{Najlepszy układ klawiszy dla języka angielskiego znaleziony przez algorytm}
\end{figure}

Porównanie wartości funkcji przystosowania oraz jej składników dla wygenerowanego układu klawiatury, oraz układów Dvorak, QWERTY oraz losowo wygenerowanego:\newline
\begin{tabular}{ c | c | c | c | c | c | c | c | c }
  układ & $p$ & $p_{finger}$ & $p_{row}$ & $p_{hand\_alter}$ & $p_{finger\_alter}$ & $p_{step}$ & $p_{isf}$ & $p_{hand\_usage}$ \\
  \hline
  losowy       & 2.44 & 0.39 & 1.5 & 0.005 & 0.16 & 0.07 & 0.009 & 0.29 \\
  QWERTY       & 3.00 & 0.11 & 2.52 & 0.005 & 0.11 & 0.09 & 0.008 & 0.14 \\
  Dvorak       & 0.30 & 0.09 & 0.029 & 0.003 & 0.06 & 0.04 & 0.008 & 0.06 \\
  wygenerowany & 0.16 & 0.01 & 0.005 & 0.004 & 0.07 & 0.05 & 0.007 & 0.002 \\
\end{tabular}\newline

Ponieważ podczas projektowania układu QWERTY nie były uwzględniane kryteria ergonomiczne, należy spodziewać się że nie będzie on znacząco lepszy od losowo wygenerowanego układu klawiszy. Rzeczywiście, funkcja oceny nie różni się istotnie w tych przypadkach. Wyraźnie lepsze wyniki osiągnął układ Dvoraka, co nie jest zaskoczeniem biorąc pod uwagę że kryteria stosowane przy jego projektowaniu w dużym stopniu pokrywają się z tymi użytymi w funkcji przystosowania. Najlepszy wynik znaleziony przez algorytm genetyczny posiada ocenę o $46\%$ korzystniejszą od najlepiej ocenionego układu wśród pozostałych, jakim jest klawiatura Dvoraka.


\section{Wyniki dla języka polskiego}

Do obliczania oceny układów klawiatury został użyty zbiór tekstów powstały przez konkatenację 10 najpopularniejszych książek w języku polskim ze strony:\newline{\tt www.gutenberg.org}.

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/fitness_time_pl}
\caption{Ewolucja maksymalnego przystosowania w populacji}
\end{figure}

\begin{figure}[!tbh]
\centering
\includegraphics[width=.8\hsize]{fig/best_en}
\caption{Najlepszy układ klawiszy dla języka polskiego znaleziony przez algorytm}
\end{figure}

Porównanie wartości funkcji przystosowania oraz jej składników dla wygenerowanego układu klawiatury, oraz układów Dvorak, QWERTY oraz losowo wygenerowanego:\newline
\begin{tabular}{ c | c | c | c | c | c | c | c | c }
  układ & $p$ & $p_{finger}$ & $p_{row}$ & $p_{hand\_alter}$ & $p_{finger\_alter}$ & $p_{step}$ & $p_{isf}$ & $p_{hand\_usage}$ \\
  \hline
  losowy       & 2.20 & 0.31 & 1.81 & 0.001 & 0.02 & 0.01 & 0.0017 & 0.02 \\
  QWERTY       & 1.87 & 0.16 & 1.64 & 0.001 & 0.02 & 0.02 & 0.0017 & 0.01  \\
  Dvorak       & 0.52 & 0.22 & 0.26 & 0.0007 & 0.015 & 0.014 & 0.0019 & 0.003  \\
  wygenerowany & 0.04 & 0.002 & 0.009 & 0.0001 & 0.015 & 0.001 & 0.0016 & 0.0001  \\
\end{tabular}\newline\newline

Układ klawiatury Dvoraka był zaprojektowany z myślą o języku angielskim, dlatego należy się spodziewać że wynik dla języka polskiego nie będzie optymalny. Rzeczywiście, układ Dvoraka jest nadal lepszy od losowo wygenerowanego lub QWERTY, ale bardzo daleki od optimum. Układ klawiszy wygenerowany przez algorytm jest natomiast wyraźnie lepszy od wszystkich pozostałych, co daje znaczącą przewagę w porównaniu z wynikami dla języka angielskiego.


% zakończenie
\summary
Wyniki osiągnięte przez poszczególne układy klawiszy pokazują jasno, że istnieją układy lepsze od tych pozostających w powszechnym użyciu i można poszukiwać ich za pomocą algorytmów genetycznych.

Użyty algorytm był stworzony z myślą o technice pisania bezwzrokowego. Interesującym problemem byłoby przystosowanie go do techniki pisania jednym palcem, która znajduje zastosowanie między innymi podczas pisania na urządzeniach posiadających ekran dotykowy. W tym celu można by zmodyfikować funkcję oceny w taki sposób, żeby algorytm minimalizował długość ścieżki jaką musi przebyć palec (lub rysik albo podobne urządzenie) podczas przepisywania zadanego tekstu. Tego typu zadanie można sprowadzić do zagadnienia Quadratic Assignment Problem (QAP), będącego jednym z klasycznych problemów optymalizacji kombinatorycznej~\cite{Ji_asolution}. Algorytmy genetyczne były już wykorzystywane z pewnymi sukcesami do rozwiązywania QAP~\cite{Misevicius200465}.

% załączniki (opcjonalnie):
\appendix
\chapter{Część programowa}

Do pracy dołączono program w języku Java, stanowiący implementację opisanego w niej algorytmu.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{bib}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
